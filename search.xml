<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[es6]]></title>
    <url>%2F2017%2F01%2F25%2Fes6%2F</url>
    <content type="text"><![CDATA[一.什么是es6 es6 是js语言的下一代标准，15年6月发布，也就是ECMAScript（2015） ECMAScript就是JavaScript的国际标准，js是es的实现 es的历史：1996年11月，网景公司把js语言提交给国际标准组织ECMA，希望能成为国际标准推广，1997年，ECMA发布ECMAScript 1.0 兼容的不是很好，但是写起来方便也多了很多新的好玩的东西 编译的话咱们就暂时先用咱们react使引入的哪个browser.js + type=‘text/bable’ 不用的话也可能能用，但是有的地方就体现不出来了，还是编译的好 为什么要有es6呢？自己想一下去吧.. 编译es6的方式： 1.浏览器编译 引入browser.js 2.gulp 二.let 和 const命令1.let：声明变量，声明的是局部变量用途及区别：ES6新增了let命令，用来声明变量，类似于var ，但是声明的变量只在let所在的代码块的内部有效 let不存在变量提升，这个要注意哟 暂时性的死区： 只要块级作用域里存在let命令，它所声明的变量就绑定这个区域，不在受外部的影响 不允许重复声明 内部的数据有了let声明过之后不允许重复声明 2.块级作用域为什么需要块级作用域： es5只有全局作用域和函数作用域，这样会造成一些不合理的地方 1&gt;.内部数据覆盖外部数据的情况 2&gt;.用来计数的循环变量泄露成全局变量 虽然没有专业的定义词语来创建块级作用域，但是只要内部用了let，就说明一个块级作用域存在了，也就是说let命令为es6增加了块级作用域 在以往我们为了让变量执行完成后就销毁不要浪费内存，会把大段的代码放到立即执行函数里，而现在，我们只需要一个块级作用域就好了 3.const ：声明只读常量 一旦声明就不能进行更改，使用起来和var，let定义的的变量一样，也是属于块级的定义方式，和let相似，也是不可重复声明的 但是对象呀，数组呀都是可以改这个对象或者数组的东西的，因为真正保存的是地址，数组多个元素少个元素又不会改变地址 12const person=Object.freeze(&#123;&#125;);var cat=Object.freeze(&#123;&#125;); 赋值的时候可以用Object.freeze来冻结一个对象，使其内部的属性和方法不能更改 4.全局对象属性全局对象是最顶层的对象，在浏览器环境指的是window对象，在node。js指的是global对象，在js语言里，所有变量都是全局对象的属性， es6规定，var 和function声明的全局变量不属于全局对象的属性，let、const、class声明的全局变量不属于全局对象的属性 二.对象的解构赋值 destructuring es6允许按照一定模式，从数组和对象里提取值，对变量进行赋值，这被成为解构赋值 1.数组的解构赋值1var [a,b,c]=[1,2,3]; 指定默认值 注意：es6内部使用严格相等运算符（===）判断一个位置上是否有值，所以如果一个数组成员不严格等于undefined，默认值是不会生效的 注意数组对应的如果不是数组的话就会报错 2.对象的解构赋值解构不仅可以用于数组，还可以用于对象 对象的属性没有次序，变量必须与属性同名，才能取到正确的值 默认值生效的条件是，对象的属性值严格等于undefined 3.函数参数的解构赋值在以前的时候，当用户传入数组或者对象的时候，需要在函数内部对这个数组或者对象进行解构并且赋值、设置默认值es6可以直接在函数的形参部分进行解构赋值和设置默认值 三：模板字符串1.es6提供了又一种变量连接字符串的方法：123var food=&apos;蛋糕&apos;;var drink=&apos;可乐&apos;; var str=`今天的早餐是$&#123;food&#125;和$&#123;drink&#125;`; 2.es6觉得可以用一个函数来搞一搞这个字符串： 利用kitchen函数来操作拼接字符串的过程，注意的是这个函数的返回值就是最终的字符串它接受两个参数，第一个是一个数组，前几位元素都是没有拼接变量时的每一个小的部分，并且这个数组有个属性叫raw，里面也会存放所有的元素 第二个参数可以用…的方式来接受所有的要拼接的变量 1234567891011 let food=&apos;蛋糕&apos;; let drink=&apos;可乐&apos;; let str=kitchen`今天的早餐是$&#123;food&#125;和$&#123;drink&#125;`; function kitchen (strings,...values) &#123; console.log(strings.raw) console.log(values) return ...&#125;console.log(str) 3.es6为字符串提供的几个小方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990let str=&apos;今天是hige好日子，心想的事儿都能成&apos;//1.判断是否是以...开头console.log(str.startsWith(&apos;今天&apos;))//true//2.判断是否是以...结尾console.log(str.endsWith(&apos;能成&apos;))//true//3.判断是否包含...console.log(str.includes(&apos;心&apos;))//true``` 四：函数相关1.设置函数参数的默认值 function fn (x=1,y=2) &#123; return [x,y] &#125; console.log(fn())2.es6里面的... 叫法有两个1.展开操作符 spread 可以在一个数组或者一个对象里快速添加另一个数组的元素或者另一个对象的属性方法，同名属性会覆盖 var fruit=[&apos;apple&apos;,&apos;banana&apos;]; var food=[&apos;meat&apos;,...fruit]; console.log(fruit); console.log(...fruit) console.log(food) var obj=&#123; name:&apos;xiu&apos;, age:13 &#125; console.log(obj) console.log(&#123;x:1,...obj&#125;) 2.剩余操作符 rest 多在函数里设置不确定数量的参数时使用 function lunch (meat,drink,...food) &#123; console.log(meat) console.log(drink) console.log(food) console.log(...food) &#125; lunch(&apos;beaf&apos;,&apos;cola&apos;,&apos;bread&apos;,&apos;baozi&apos;) 3.name属性 es6为函数增加了一个name属性，需要注意的是，匿名函数的name是引用的变量的名字，又赋值又有名字的函数name是函数自己的函数名 function myFn (argument) &#123; &#125; console.log(myFn.name)//myFn var yourFn=function()&#123; &#125; console.log(yourFn.name)//yourFn var hisFn=function herFn()&#123; &#125; console.log(hisFn.name)//herFn4.es6新增了箭头函数这样的定义函数的方式，箭头前面的是函数的参数，多个参数可以用()包裹，没有参数也要写（），箭头后面的是函数的返回值，如果写成&#123;&#125;包裹的话,就是函数体，需要返回值的时候要return var fn=a=&gt;a+1; // function fn (a) &#123; // return a+1; // &#125; console.log(fn(5))//6 var fn2=(a,b)=&gt;&#123; return a+b; &#125; // function fn2(a,b)&#123; // return a+b; // &#125; console.log(fn2(1,2))//3## 五：变量添加属性和方法es6 觉得如果一个对象想拥有和一个变量的名字一样的键名，并且值为这个变量的值的属性的话，可以直接在键值对里直接写一个变量名就好， 如果想设置一个方法，可以直接写方法名（）&#123;&#125; let name=’allen’, age=13; let person={ name, age}console.log(person) var laugh=()=&gt;{alert(‘hahaha’)}let xiu={ laugh, sayHello(name=’美女’){alert(${name},你好)}, …person}xiu.laugh();xiu.sayHello();xiu.sayHello(‘baobao’);12345## 六：es6中对象的属性名可以用变量的值去表示 let person={}; person.name=’xiuxiu’; person.firstName=’zhao’; person[‘second name’]=’wang’; let myname=’third name’ person[myname]=’gao’; console.log(person)12345## 七：几个Object的方法###### 1. Object.is方法，可以做神奇的相等比较，类似为安格拉小姐 console.log(+0==-0)//true console.log(+0===-0)//true console.log(NaN==NaN)//false console.log(NaN===NaN)//false console.log(Object.is(+0,-0))//false console.log(Object.is(NaN,NaN))//true123###### 2.Object.assign。可以用来把某一个对象里面的属性复制另一个属性里，同名会覆盖，按照顺序 var person={};Object.assign(person, {name:’zhaoxiu’}, {name:’wangxiu’}, {age:18})console.log(person)//{name:wangxiu,age:18}12345###### 3.Object.prototype相关 var a= Object.create(b)//把b作为原型来创建一个对象aObject.getPrototypeOf(a)//获取a的原型Object.setPrototypeOf(a,c);把a的原型设置为c var wang={ getName(){ return ‘王’ }}var li={ getName(){ return ‘李’ }} var xiu=Object.create(wang);console.log(xiu.getName())//王 console.log(Object.getPrototypeOf(xiu)==wang)//trueObject.setPrototypeOf(xiu,li);console.log(xiu.getName())//李console.log(Object.getPrototypeOf(xiu)==li)//true1234通过&#123;&#125;.prototype可以来设置原型，但是输出出来的却是__proto__,es6觉得，那就直接设置__proto__吧 var wang={ getName(){ return ‘王’ }}var li={ getName(){ return ‘李’ }} var xiu={ proto:wang}console.log(xiu.getName())//王 console.log(Object.getPrototypeOf(xiu)==wang)//truexiu.proto=liconsole.log(xiu.getName())//李console.log(Object.getPrototypeOf(xiu)==li)//true12345在对象的方法里可以使用它原型的方法和属性，这个时候在方法里用super来代表自己的原型 var wang={ getName(){ return ‘王’ }}var xiu={ proto:wang, getFname(){ console.log(super.getName()) }}console.log(xiu)xiu.getFname()123456789## 八：class类es6里引入了类的概念，可以通过class关键字来创建一个类，里面的contructor方法可以用来接受实例化时传入的参数，还可以在class里写一些自定义的方法,不需要加，哦 class person {constructor(name){ this.name=name} say(){ console.log(this.name)}} var xiu=new person(‘xiu’)console.log(xiu)//…..personname:”xiu”proto:Objectconstructor:person(name)say:say()proto:Object//………… xiu.say()///xiu12345es6觉得获取属性和设置属性的这些操作可以专门用set和get关键字来定义 class person { constructor(name){ this.name=name; this.hobby=[]; } get gethobby(){ return this.hobby; } set sethobby(hobby){ return this.hobby.push(hobby); } } var xiu=new person(‘xiu’)console.log(xiu.hobby) //[]console.log(xiu.gethobby) //[]console.log(xiu.sethobby=’sing’) //singconsole.log(xiu.hobby) // [‘sing’]console.log(xiu.gethobby)// [‘sing’]12345static 可以设置一个这个类自己的静态方法，只有类可以调用，实例不可以调用 class person { constructor(name){ this.name=name; } say(word){ console.log(word) } static superSay(word){ console.log(word) } } var xiu=new person(‘xiu’);xiu.say(‘hello’)//person.say(‘hello’)//error//xiu.superSay(‘hello’)//errorperson.superSay(‘hello’)12345es6的class里，可以用extentds来进行继承class Student extends Person&#123; &#125;，但是如果父类通过constructor接受了参数，并且之类需要接受更多的参数，那么需要在子类的constructor里用super来给父类contructor传递参数，剩下的再自己使用 class Person { constructor(name,age){ this.name=name; this.age=age; } say(){ console.log(`${this.name},${this.age}`) } } new Person(‘xiu’,18).say()//xiu,18 class Student extends Person{ constructor(name,age,sex){ super(name,age) this.sex=sex }}console.log(new Student(‘liu’,13,’male’))123456789## 九：集合类型- 1.es6新增了Set这个集合类型，类似与数组，但是还是有不少区别，比如，Set里不能有重复元素，重复元素不报错但是也不会添加进去 通过new Set（）来创建。初始参数是字符串 其他的要报错，会把字符串拆开了作为元素 var _set=new Set(‘123’) console.log(_set)//Set {“1”, “2”, “3”}123Set里不能有重复元素，重复元素不报错但是也不会添加进去 var _set2=new Set(‘1223’) console.log(_set2)//Set {“1”, “2”, “3”}1234通过add方法来添加新元素 并且新添加是什么类型就是什么类型 var _set3=new Set(‘123’)_set3.add(4)console.log(_set3)//Set {“1”, “2”, “3”,4}` 通过size来获取元素个数 var _set4=new Set(&apos;123&apos;) console.log(_set4.size)//3 通过delete来删除元素 var _set5=new Set(&apos;123&apos;) _set5.delete(&apos;3&apos;) console.log(_set5)//Set {&quot;1&quot;, &quot;2&quot;} 通过has来判断有没有这个元素 var _set6=new Set(&apos;123&apos;) console.log(_set6.has(&apos;3&apos;))//true 可以通过forEach来遍历 var _set7=new Set(&apos;123&apos;) _set7.forEach((x,i)=&gt;{ console.log(`${x},${i}`) }) // 1,1 // 2,2 // 3,3 通过clear来清除元素 var _set8=new Set(&apos;123&apos;) _set8.clear(); console.log(_set8)//Set {} 2.map，es6新增了map这样的类型，和{}的区别就是可以用任何数据类型作为键值 let map=new Map(); //获取一个map let [obj,fn,str]=[{},function () {},&apos;hello&apos;]; map.set(obj,&apos;obj&apos;) //设置map的键值对 map.set(fn,&apos;fn&apos;) map.set(str,&apos;str&apos;) console.log(map) console.log(map.size)//获取map的键值对个数 console.log(map.get(obj)) //获取map的键对应的值 console.log(map.delete(fn)); //删除某一个键值对 console.log(map.has(fn)) //检测是否包含某个键名 console.log(map.has(obj)) map.forEach((value,key)=&gt;{ //可以用forEach来遍历map console.log(value) console.log(key) }) map.clear(); //清空map的键值对 console.log(map) 10.模块系统 在es6里引入了模块的概念，但是得要编译，这里在node环境演示]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础入门]]></title>
    <url>%2F2015%2F12%2F08%2Fjs%2F</url>
    <content type="text"><![CDATA[什么是JavaScript？12345JavaScript是用来实现web页面交互效果的，提升用户体验。web页面中的三层：结构层 从语义上来讲，用来布局页面结构表现层 从审美角度来讲，修饰、美化页面行为层 从交互角度来讲，提升用户体验 JavaScript中的输出方式123alert()console.log()document.write("&lt;h1&gt;文字&lt;/h1&gt;") JavaScript的外部连接.js文件1&lt;script src=&quot;xx.js&quot;&gt;&lt;/script&gt; JavaScript的代码书写规范 1231、每一行语句换行2、有嵌套的代码要有缩进3、语句的结束标志 分号 或 换行 JavaScript 中的 字面量 （直接量）123456789101112131415161718192021222324252627由 数值类型 和 字符类型 组成数值类型： 整数 小数 整数：1 2 3 4 5 6 0x34 进制： 十进制 0--9 组成的数 二进制 0--1 组成的数八进制 0--7 组成的数 一般八进制 以 0 开头 034 十六进制数 0--9 a--f 组成的数 一般十六进制 以 0x 开头 0x34 0xaf3如何实现进制转换：toString() 将某一个进制数 转成另一个进制数 如果 括号中 有参数，参数就是要转成的进制数如果 括号中 没有参数， 就会将toString()左边的数据转成 字符类型实例：(12).toString(16) 将十进制的12 转换成 16进制数将 2、8、16 转成10进制 还有一个方法：parseInt() 如果有一个参数，就是将字符串类型的数字转成 整数 比如： parseInt(&quot;12abc&quot;) 结果就是 12parseInt() 如果有两个参数，第一个参数是 操作数，第二个参数是操作数的进制 ， 含义将该进制转成 10进制比如： parseInt(1101,2) 含义就是将二进制的 1101 转成十进制 parseInt(16,16) 含义就是将十六进制的 16 转成 十进制 字符类型： 由双引号 或 单引号括起来 注意： 引号嵌套的问题 &quot; &apos; &apos; &quot; 或 &apos; &quot; &quot; &apos; JavaScript的数据类型12345678910111213141516基本数据类型： 字符型 string 字符类型的数据组成 多个 ，引号括起来就可以 数值型 number 数值类型的数据组成 多个 整数 和 小数 1.1+ 0.1 = 1.2000000000000002 有精度问题，如果实现保留两位小数：toFixed(2) (1.1+0.1).toFixed(2) 布尔型 boolean 布尔类型数据 由 true 和 false 组成复合数据类型：（引用数据类型） 对象 object 数组 Array特殊数据类型： null ： 表示 空 undefined ：表示 未定义 用来测试某个数据属于哪一个数据类型：typeof() typeof( typeof( ) ) ----string 变量12345什么是变量？ 程序运行过程中，值可以改变的量变量定义： 通过 var 定义 （int float double char ） 变量一定要先定义 后使用 运算符和表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980算术运算符： + - * / % (双目运算符) + ： 运算（如果+两次都是数值类型，就表示运算） 连接（如果+某侧有一个字符串类型，就表示连接） / : 如果需要整除（parseInt() 转换 ） 4/3 = 1.3333 % (模): 4%3 = 1 练习： 有一个四位数3215，编程实现这四位数中各个位数的和（3+2+1+5 = 11） &lt;script type=&quot;text/javascript&quot;&gt; // 34%10 129%10 8977%10 2%23 12%123 // 3215 var a = 3215; g = a%10;//5 s = parseInt( a/10 ) %10; b = parseInt(a/100) %10; q = parseInt(a/1000);// 3%10 alert( g+s+b+q );&lt;/script&gt; ++ -- (单目运算符) 自增++ 自减-- var i=9,j; j = i++; i= 10 j =9 先赋值 后自增 var i=9,k; k = ++i; i=10 k = 10 先自增 后赋值 实例： var k = -2 alert( ++k + k++ + --k + k );关系运算符： &gt; &gt;= &lt; &lt;= == !=（不等于） !==(不全等) ===全等 关系表达式的结果 ： 如果关系表达式成立，结果为true，否则为 false ==：比较值 ，如果两侧的值相等，结果为 true ===： 比较值和类型，如果两侧的值和数据类型均相等，结果为 true &quot;12&quot; == 12 true &quot;12&quot; !=12 false &quot;12&quot; === 12 false &quot;12&quot; !== 12 true逻辑运算符： &amp;&amp;与 ||或 ！非 &amp;&amp; : 如果两侧都是true，结果才是true，否则为 false true&amp;&amp;true ==&gt;true || : 如果两侧都是false，结果才是false，否则为 true false || false ==&gt; false ! : !true==&gt;false !false ==&gt;true 非真即假，非假 即真在JavaScript中，参与逻辑运算的都是布尔值 3&gt;4 || 2&lt;3 ==&gt;true 2==1 &amp;&amp; !false ==&gt; falsevar i=9;alert (3&gt;4 &amp;&amp; i++) falsealert( i ) 9alert(3&lt;4 || ++i)alert(i)短路问题： 如果 false 遇到 &amp;&amp; ,&amp;&amp; 后面的表达式不执行 如果 true 遇到 || ,|| 后面的表达式不执行 条件运算符： ? : ( 三目运算符 ) 表达式1 ？ 表达式2 ： 表达式3 如果表达式1的结果为true，取表达式2的值作为整个条件表达式的值 如果表达式1的结果为false，取表达式3的值作为整个条件表达式的值 一般表达式1为一个 条件表达式 2&gt;3 ? 45:32 ;==&gt; 32赋值运算符： = ：表示将右边的值赋值给左边的变量, = 左边是一个变量 i+2 = 9 写法错误; i=90+j; 复合赋值运算符： += -= *= /= %= 练习：已知： a=23,b=90;将a和b的值交换后输出（考虑在不使用第三个变量的情况）；t = 0;t = a; a = b; b = t; 需要第三个变量t不考虑用第三个变量：a = a+b;b = a-b; // 23 a = a-b; //90 类型转换12345678Number() 将某一个数据 尝试 转成 number 类型 如果参数不是一个纯数字的字符串，结果就是NaNString() 将某一个数据 尝试 转换 string 类型Boolean() 将某一个数据 尝试 转换 boolean 类型 ，结果只有true和false，js中的 0为假，非0为真，空字符串为假，字符串为真isNaN() 判断某字符串是否是纯数字 如果参数是纯数字字符串，结果false，否则为trueparseInt() 将某一个字符串 转成整型 parseInt(&quot;aa23&quot;) ==&gt; NaN praseInt(&apos;2d3aa&apos;) ==&gt; 2parseFloat() 将某一个字符串 转成 小数 parseFloat(&quot;23.45ssss&quot;)==&gt;23.45 parseFloat(&quot;23.rrrddd45&quot;)==&gt;23; 变量格式转入 方法123prompt() 弹出一个对话框 ， 包含一个输入框，一个确定一个取消按钮，如果点击确定，返回输入框的内容，点击取消返回null第一个参数：提示文字第二个参数：（可以省略）： 默认内容 程序的三大结构123顺序 ：程序从上到下按照一定的顺序执行选择循环 选择结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061单分支：if(表达式)&#123; 语句1； &#125;if(表达式)&#123; 语句1；&#125;else&#123; 语句2；&#125;如果表达式结果为真，执行if语句，否则执行else 语句练习： 判断用户输入的密码是否正确，如果是 123，那么就弹出正确；如果不是，就弹出错误。 计一年算某是否是闰年 闰年定义：能被4整除并且不能被100整除，或者能被400整除的就是闰，输入任意一个年份，判断是否是闰年 注意：在js中，当遇到布尔环境时，非布尔类型的值会自动转换为布尔类型以下几种情况为false（假）：1）、数值 0 为 假，非0为真2）、字符串&quot;&quot; 空为假，非空字符串为真3）、null和undefined为假4）、所有对象为真 多分支if(表达式1)&#123; 语句1；&#125;else if（表达式2）&#123; 语句2；&#125;练习：根据 BMI （身体质量指数）显示一个人的体型。BMI 指数，就是体重、身高的一个计算公式。公式是：BMI = 体重÷身高的平方 (单位是米)过轻：低于 18.5正常： 18.5-24.99999999过重： 25-27.9999999肥胖： 28-32非常肥胖 , 高于32var a=10;if(a&gt;5)&#123; a = a+3;&#125;else if(a==13)&#123; a = a+4;&#125;else if(a==17)&#123; a = a+5;&#125;else&#123; a = a+6;&#125;if语句嵌套：if(表达式1)&#123; if(表达式2)&#123; 语句 &#125;&#125;例如：征兵入伍条件： 男 年龄 18岁以上 if语句使用时需要注意的问题：12341、else 部分可以省略2、else 部分 不可以独立存在3、else 后面 不允许条件条件 else(条件)--错误4、if 后面 如果有一条语句，&#123;&#125; 是可以省略的 switch（开关语句，多分支）1234567891011switch(常量表达式)&#123; case 常量表达式1 : 语句1; break; case 常量表达式2 : 语句2; break; .... default: 语句n;&#125;执行过程：根据switch 括号中常量表达式的值 与 case 后面的常量表达式的值做比较，如果找到有相等的，就执行该case对应的 语句如果case 中的常量表达式 没有和 括号中相等的，则 执行 default 语句 循环 for12345678910111213141516171819循环：解决重复编写的代码循环的要素： 1、循环变量的初始值 2、循环条件 3、循环变量增值（步长） 4、循环体（重复实现的代码）共性代码：原样写出个性代码：拿循环变量代替for循环语法格式：for(表达式1;表达式2;表达式3)&#123; 循环体; (如果循环体中只有一条语句，花括号可以省略)&#125;表达式1：给循环变量赋初始值表达式2：循环条件表达式3：循环变量增值for(i=1;i&lt;=100;i++)&#123;...&#125;for(i=1,j=0;i&lt;=100,j&lt;=10;i++)&#123;&#125;执行过程： 关于 数的概念 问题12345678910因数：可以被某个数整除的数，那么这个数就是该数的因数例如： 8的因数有： 1 2 4 8 12 的因数有： 1 2 3 4 6 12素数（质数）：只能被1 和 其本身整除的数例如： 2 3 5 7 11 13 .......完数： 一个数的因子之和等于该数本身，那么这个数就是完数 （注意：这里的因子不包括该数本身）6 ： 1 2 3 28： 1 2 4 7 14 for循环的小知识点1234567891011121、表达式1可以在for语法中省略var i=1;for(;i&lt;=10;i++)&#123;...&#125;2、表达式3可以在for语法中省略for(var i=0;i&lt;=10;)&#123; i++;&#125;3、表达式2可以在for语法中省略,一旦省略了表达式2，就会出现 “死循环”死循环： 程序无条件执行，无限循环for(var i=0;;i++)&#123; &#125; for嵌套123双层for循环练习：输出 100---200之间所有的素数 while和do..while12345while的语法格式：while(条件)&#123; 循环体&#125;执行过程：先判断，后执行（循环体有可能一次也不执行） 12345do....while的语法格式：do&#123; 循环体&#125;while(条件);执行过程：先执行，后判断（循环体至少执行一次） while循环和for循环的使用场景12已知循环次数，建议用for未知循环次数，建议用while 或 do..while() break和continue12break ：跳出本层循环continue：跳出本次循环，继续执行下一次循环 初步认识函数1函数：函数就是一小段代码块（为了实现某个功能） 一个工具，屏蔽了内部细节 函数种类1234567891011121314系统函数 ： alert() prompt() 自定义函数: 通过 function 来定义 function定义一个函数，是一个关键字，就像 var typeof 一样 函数名命名规范 同变量的命名规范 （不能使用关键字、不能用数字开头、只能由字母、数字、下划线、$组成） 定义一个函数： function 函数名 ()&#123; 函数体 &#125; 注意： 函数名不能省略 function ()&#123;......&#125; 函数体不能写到小括号中 function fun(&#123;..........&#125;) 函数调用12函数名(); 函数调用可以写在函数定义前或定以后。 函数的参数12345678910形式参数： 1、形参一定是一个变量，这个变量不能用var修饰 2、形参出现在函数定义中 3、形参个数 要 和实参 一致 4、形参的值由实参来决定实际参数 1、实际参数可以是一个变量、一个表达式、一个字面量，但是实参一定要有具体的值 2、实参出现在函数调用中 3、通过函数调用 将实参的值传递给 形参 4、参数传递过程中，形参和实参是一一对应的，也就是说第一个实参值传递给第一个形参 函数的返回值12345671、函数的返回值是通过 return 来返回的 2、一个函数如果有返回值，有且仅有一个。3、函数可以没有返回值，结果在函数体中直接输出。4、有返回值的函数，在调用函数时，进行输出，否则得不到结果5、一个函数可以有多个return，但是只有第一个return起作用6、一个函数一旦遇到return，return后面的语句将不在执行7、一个函数功能实现后如果得到一个结果值，建议将这个值通过return返回，而不是直接在函数中输出 函数的递归调用12345678函数自己调用自己阶乘问题：6! = 6*5!5! = 5*4!4! = 4*3!3! = 3*2!2! = 2*1;已知 1！ = 1 变量提升123456789101112变量提升：在函数体内部定义的变量，会将变量提升到函数的最顶端，只提升声明，但不赋值。例如：function fun()&#123; alert(num); var num=10;&#125;等价于：function fun()&#123; var num; alert(num); // undefined num=10; alert(num); //10&#125; 变量的作用域123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687全局变量：在函数体外部定义的变量。 全局变量的作用范围：从程序的开始到程序结束均有效。隐式全局变量：在函数体内部没有被var声明的变量。局部变量： 在函数体内部通过var明确定义的变量。局部变量的作用范围： 只在函数体内部有效。跳出函数体，变量失效。局部变量的优先权大于全局变量。var a = 10;function fun()&#123; var m = 10; x = 10; a = 20; alert(a); // 20&#125;fun();alert(x); // 10alert(m); // 报错 练习： var a=10; function fun()&#123; a=&quot;global&quot;; &#125; console.log(a); // 10 ----------------------------------- var a; function fun()&#123; a=&quot;global&quot;; &#125; fun(); console.log(a);// global ----------------------------------- var a=1; function fun()&#123; a=b=2; &#125; fun(); alert(a); // 2 alert(b); // 2 ------------------------------------ function aa()&#123; a = 10; var b = 20; &#125; aa(); console.log(a); // 10 console.log(b); // 报错 ----------------------- var a=18; f1(); function f1()&#123; var b=9; console.log(a); // undefined console.log(b); // 9 var a=&apos;123&apos;; &#125;--------------------------- 经典的面试题： f1(); console.log(c)//9; console.log(b)//9; console.log(a);//报错 function f1()&#123; var a=b=c=9; //a为局部变量 b和c都是隐式全局变量 console.log(a); //9 console.log(b); //9 console.log(c); //9 &#125; ------------------------- var num=10; fun(); function fun()&#123; console.log(num); //undefined var num=20; &#125; 同名函数12项目中如果两个或多个函数的函数名相同，即为同名函数。如果有同名函数，只执行最后一个函数体的内容。 实参副本（arguments）1234567函数中的arguments： 1、表示收到的实参副本，也就是说 代表所有的实参 2、arguments只能在函数体内部使用 3、arguments表示一个对象，并不表示数组，虽然用法和数组一样。 4、arguments的索引下标从0开始的获取实参的个数： arguments.length获取形参的个数： 函数名.length 获取任意区间的随机数公式1234567Math.random() 获取 [0,1) 之间的任意一个随机小数 Math.random()*10 [0,10)Math.floor( Math.random()*10 ) [0,9] Math.floor( Math.random()*10 ) + 1 [1,10]获取任意区间值的公式：Math.floor( Math.random()*(大数-小数+1) ) + 小数 3--19 数组1234567什么是数组：一组数据的集合（js数组可以存放任意类型的数据）其它强类型语言：（扩展）： 一组具有相同数据类型的有序的集合。js数组的特点： 可以动态的添加数据或删减数据 数组长度不是固定的 数组中存放的数据可以不连续 数组中的数据可以是任意类型 数组的定义123456789var arr = []; 定义一个空数组var arr = new Array(); 定一个空数组var arr = [23,true]; 定义一个数组，含有两个值var arr = new Array(10); 定义一个数组，长度为 10 var arr = new Array(10,20); 定义一个数组 ，含有两个值通过下标 操作数组中的值 下标从0开始数组长度获取： 数组名.length 数组的最大下标： 数组名.length-1 数组的操作12345678910111213141516171819202122232425push() 向数组尾部添加新元素 语法： 数组名.push(新元素1[,新元素2,......])pop() 从数组尾部删除一个元素，返回删除的元素语法： 数组名.pop()shift() 从数组首部删除一个元素，并返回删除的元素,得到的是删除元素语法： 数组名.shift()unshift() 向数组首部添加新元素 语法： 数组名.unshift(新元素,[新元素2,...])concat() 将两个或多个数组连接起来，合并成一个新数组，不会改变原来的数组语法： 数组a.concat(b) 将b数组连在a数组之后 join() 通过一个指定的字符将 数组转成字符串语法： 数组名.join(&apos;字符&apos;)slice() 从开始位置截取，到结束位置，截取的数据不包括结束位置处的数据 (不改变原数组)语法： 数组名.slice(start,end); splice() 从开始位置截取指定长度的数据，（改变原素组）语法： 数组名.splice(start,length);reverse() 数组翻转 语法： 数组名.reverse() 选择排序12345每轮比较都会有一个基准值，第一轮以 数组中第一个数a[0] 和后面的每一个数进行比较，如果 这个数大于后面的数，就交换第二轮以 数组中第二个数a[1] 和后面的每一个数进行比较，如果 这个数大于后面的数，就交换...每轮完成后，都会找到一个最小值（每一轮都有一个假设的最小值，从a[0]开始） 简单选择排序123每轮比较时，假设一个最小值下标:第一轮假设 0 为最小值下标，遍历数组，根据最小值的下标，依次比较假设是否成立，如果最小值下标0对应的值并不是最小的，最小值下标改变。 如果最小值下标改变，就交换，否则就不交换。 数组中的排序方法：sort12345sort()方法使用： 数组名.sort( 函数名 ) function fun(a,b)&#123; return a-b; //升序 return b-a; 降序 &#125; 二维数组（js中没有真正的多维数组）123456二维数组：由行和列组成的，存储的数据是连续js中如果数组中存储的数据也是一个数组，可以通过 数组名[][] 这种双下标的格式将数据取出来，这种双下标取数据的方式类似与二维数组。js中没有二维或多维数组。定义一个两行两列的二维数组：var arr = [[1,2],[3,4]]; js的内置对象123456789101112131415161718字符串对象 String对象字符串定义：var str = &quot;&quot; 或 &apos;&apos;var str = new Array(&quot;hello world&quot;);获取字符串中的字符：str[下标] 下标从0开始获取字符串长度属性： length 练习： 给定一串字符，检索这个字符串中是否包含a。 //判断某个字符串中是否含有某个字符 var str = &quot;hello&quot;; for (var i=0;i&lt;str.length;i++) &#123; if(str[i]==&quot;a&quot;)&#123; alert(&quot;包含a字符&quot;); break; &#125; &#125; if(i==str.length)&#123; alert(&quot;字符串中没有字符a&quot;); &#125; 字符串的操作方法123456789101112131415161718192021222324252627282930313233343536373839404142charAt() 查找某个索引位置处的字符语法： 字符串对象.charAt(索引) charCodeAt() 查找某个索引位置处的字符的Unicode值 语法： 字符串对象.charCodeAt(索引)String.fromCharCode() 根据某字符的Unicode值 获取对应的字符 和charCodeAt结果相反语法 ： String.fromCharCode(Unicode值) 这是一个静态方法，通过类名String 直接调用练习：给定一串字符，str = “232#￥fdfsADd333￥￥&amp;a”; 统计大写字母、小写字母、数字、和特殊字符的个数，编程实现一个字符串的实际长度（扩展） 一个汉字在内存中占 两个字符 的位置 str = &quot;hello大家好&quot;;--计算这个字符串的实际长度（在内存中占的长度）indexOf()：查找某个字符在字符串中首次出现的位置，如果找不到，返回-1语法： 字符串对象.indexOf(&apos;字符&apos;) lastIndexOf()：查找某个字符在字符串中最后一次出现的位置，如果找不到，返回-1语法： 字符串对象.lastIndexOf(&apos;字符&apos;)split() 根据字符串中的某个字符将字符串拆分成 数组 （将字符串转换成数组）语法： 字符串对象.split(&apos;字符&apos;)substr() 从开始位置截取 指定长度的字符语法： 字符串对象.substr(start,length) substring() 从开始位置截取字符串 到 结束位置，并不包括结束位置处的字符语法： 字符串对象.substring(start,end) trim() 去掉字符串左右两端的空白字符语法：字符串对象.trim() replace() 替换 （只替换一个）语法： 字符串对象.replace(&quot;原字符&quot;,&quot;新字符&quot;);toLowerCase() 转小写字母语法：字符串对象.toLowerCase()toUpperCase() 转大写字母语法：字符串对象.toUpperCase() 数学对象12345678910111213Math.ceil() 向上取整Math.floor() 向下取整Math.round() 四舍五入Math.abs() 取绝对值Math.pow(x,n) 取x的n次方Math.sqrt(x,n) 开n次方（开根号）Math.random() 获取[0,1) 之间的随机数 获取任意区间的随机数公式： Math.floor(Math.random()*(max-min+1))+min parseInt(Math.random()*(max-min+1))+min封装一个函数，获取任意区间的一个随机值：function rand(min,max)&#123; return Math.floor(Math.random()*(max-min+1))+min; &#125; 操作标签内容12345678innerHTML 获取或设置文本标签的内容 （识别网页标记）innerText 获取或设置文本标签的内容（将网页标记作为文本内容）--- 火狐不识别操作表单内容：value 获取或设置表单的value值 获取时：对象.value 设置时：对象.value = &quot;值&quot; 日期对象Date123456789101112131415161718192021定义一个当前日期时间对象： var d = new Date();自定义一个日期时间对象： var birth = new Date(&quot;1993-09-09&quot;);日期对象的操作方法：getFullYear() 获取年份getYear() 获取年份 （ie6识别）兼容写法：if（d.getFullYear）&#123; d.getFullYear();&#125; else&#123; d.getYear();&#125;getMonth() 获取月份 月份从0开始 getDate() 获取日期getDay() 获取星期 0 表示 星期日 1 星期一getHours() 获取小时getMinutes() 获取分钟getSeconds() 获取秒 toLocaleString() 将标准的日期时间格式 转成 本地格式显示getTime() 获取一个毫秒值 获取从1970年1月1日 零点到现在时间的一个毫秒值setTime( 毫秒 ) 设置一个毫秒值 BOM对象123456什么是bom对象：浏览器对象模型BOM对象的顶级对象是 ： windowwindow下面有几大属性，这几个属性本身又是一个对象window对象的属性（对象）： document、location、history、screen、navigator（location既是window对象的属性，也是document对象的属性 window.location === document.location (扩展) ）window.document.getElementById()---所以说 document 是window对象的一个属性 ，但document本身也是一个对象 window对象12345678910111213141516171819202122232425262728293031window对象的属性和方法在使用时可以省略 window.属性： closed 判断某个窗口是否被关闭，如果窗口没有被关闭，返回false，否则返回true opener 获取某个窗口对象的父级窗口 status （扩展） 显示内容在状态栏上 方法： 三个弹出对话框窗口： alert() 弹出一个警告框 confirm() 弹出一个确认框 带有确认和取消按钮，点击确认，返回true，点击取消返回false prompt（） 弹出一个输入框 带有 输入框 确认和取消按钮，点击确认返回输入的内容，点击取消返回null 一个弹出窗口： 超链接也可以弹出一个窗口，但是超链接弹出的窗口和父窗口之间没有任何关系，是独立的，也就是说两个窗口之间不能互相操作。 open(&quot;url&quot;,&quot;_blank&quot;,&quot;弹出窗口的外观&quot;) 通过open（）方法弹出的窗口，会返回一个值，这个值表示一个窗口对象，也就是子窗口对象。 子窗口对象 和 父窗口对象之间是可以互相操作的 弹出窗口的外观： width height left top 这四个值 没有什么兼容问题，其它的属性 对于不同的浏览器就会有不同的显示 location 是否有地址栏 yes | 1表示有 no | 0 表示 没有 toolbar 是否有工具栏 scrollbars 是否有滚动条 resizable 是否可调整窗口大小 focus() 是某个窗口总是处于最前端 close() 关闭窗口 两个定时器 ： setInterval(要执行的任务，间隔时间) 连续执行的定时器 （延时） clearInterval(定时器名称) 停止定时器 setTimeout(要执行的任务，间隔时间) 一次性定时器（延时） clearTimeout(定时器名称) 停止定时器 06—end]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo笔记]]></title>
    <url>%2F2015%2F11%2F08%2Fhexo%2F</url>
    <content type="text"><![CDATA[官网Hexo! 快速开始创建一个新帖子1$ hexo new "My New Post" 运行服务器1$ hexo server 生成形态文件1$ hexo generate 部署到远程站点1$ hexo deploy 安装动态背景themes/next/layout/_layout.swig里面的header下面设置有四种背景：12345678910111213141516&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/three_waves.js/1.0.0/three_waves.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas_lines.js/1.0.0/canvas_lines.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125;&#123;% if theme.canvas_nest %&#125; &lt;script type=&quot;text/javascript&quot; color=&quot;0,0,255&quot; opacity=&apos;0.7&apos; zIndex=&quot;-2&quot; count=&quot;99&quot; src=&quot;//cdn.bootcss.com/canvas_sphere.js/1.0.0/canvas_sphere.min.js&quot;&gt;&lt;/script&gt;&#123;% endif %&#125; 然后themes/next/_config.yml里面设置：1234567891011# Canvas-nestcanvas_nest: true# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false 重新：hexo clear —-hexo g—– hexo s 运行；安装主题123456789地址next主题：git clone https://github.com/iissnan/hexo-theme-next themes/next主题配置：theme: next主题模式：#scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue随笔]]></title>
    <url>%2F2015%2F11%2F08%2Fvue%2F</url>
    <content type="text"><![CDATA[Vue是什么?Vue.js是一套构建用户界面（view）的MVVM框架。Vue.js的核心库只关注视图层，并且非常容易学习，非常容易与其他库或已有的项目整合。vue谷歌调试插件vuetoolsVue 与 react相同点 （什么是以下特点？后期查资料）1.利用虚拟dom实现快速渲染2.轻量级3.响应式组件4.服务端渲染5.易于集成路由工具、打包工具以及状态管理工具 一、Vue.js的目的Vue.js的产生核心是为了解决如下三个问题： 解决数据绑定的问题； Vue.js框架生产的主要目的是为了开发大兴单页面应用（SPA：Single Page Application）Angular.js中对PC端支持的比较良好，但是对移动端支持就一般。而Vue.js主要支持移动端，也支持PC端。 它还支持组件化。也就是可以将页面封装成若干个组件，采用积木式编程，这样是页面的复用度达到最高（支持组件化）。二、Vue.js特性 MVVM模式M: model 业务模型，用处：处理数据，提供数据V: view 用户界面、用户视图业务模型model中的数据发生改变的时候，用户视图view也随之变化。用户视图view改变的时候，业务模型model中的数据也可以发生改变。 组件化 指令系统 Vue.js 2.0开始支持虚拟DOM（Vue.js 1.0 是操作的真是DOM，而不是虚拟DOM）虚拟DOM可以提升页面的刷新速度。三、入门语法篇使用Vue.js的步骤：第一步：在html页面中引入vue.js;第二步：Vue.js提供了一个Vue,我们需要创建一个对象。new Vue({}); 123456&lt;script&gt; var app = new Vue(&#123; el:"#demo",//声明vue.js管理的边界 data:&#123;&#125;//data核心作用是存放在页面中的数据,需要是一个对象 &#125;)&lt;/script&gt; 第三步：在用户界面view中，通过–双大括号–形式将data中的数据显示在页面中。在用户界面中， 双大括号–代码中绑定的data的key，而在页面中显示的是该key的value。Vue.js对获取的data与页面上显示的–双大括号–会产生一种映射关系。注： 双大括号–可以识别HTML标签；例：12&lt;div&gt;&#123;&#123;&#123;name&#125;&#125;&#125;&lt;/div&gt;data&#123;name：&lt;h1&gt;liqingyu&lt;/h1&gt;&#125; 12345678910111213&lt;div id=&quot;demo&quot;&gt;&#123;&#123;name&#125;&#125;,你好!!!&lt;/div&gt;//&#123;&#123;name&#125;&#125; vue中的 data的健名,当渲染之后会显示对应的值,当data中的name发生变化时,&#123;&#123;&#125;&#125;中的值也会随之变化&lt;script&gt; var app = new Vue(&#123; el:&quot;#demo&quot;,//声明vue管理的边界 data:&#123; name:&quot;liqingyu&quot; &#125;//data核心作用是存放显示在页面中的数据,需要是一个对象 &#125;)&lt;/script&gt;//app相当于data控制台修改:app.name = &quot;青宇&quot; //app这个变量会代理vue中的data数据&quot;青宇&quot;// 这样，如果我们要实现前后台交互，只要将从后台得到的数据，放在data中,页面就会自动绑定，这样就实现了从model-&gt;view的数据流向。四、指令指令，其实指的就是vue的v-开头的自定义属性。每个不同的属性都有各自不同的意义和功能。指令的语法：v-指令名称=”表达式判断或者是业务模型中属性名或者是事件名”1、 v-text作用：操作元素中的纯文本 快捷方式：12345678910111213141516171819202122232425262728&lt;h1 id=&quot;demo&quot; v-text=&quot;&apos;今年是&apos;+year+&apos;年&apos;+month+&apos;月&apos;&quot;&gt;&lt;/h1&gt;//v-text=&quot;&quot; 这里面的引号是vue界限符号,并非字符串引号,所以里面是字符串的时候需要另加引号&lt;script&gt; var app = new Vue(&#123; el:&quot;#demo&quot;, data:&#123; year:new Date().getFullYear(), month:new Date().getMonth()+1 &#125; &#125;)&lt;/script&gt;&lt;div id=&quot;demo&quot;&gt; &lt;p&gt;姓名:&#123;&#123;person.name&#125;&#125;&lt;/p&gt; &lt;p&gt;年龄:&#123;&#123;person.age&#125;&#125;&lt;/p&gt; &lt;p&gt;性别:&#123;&#123;person.sex&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:&quot;#demo&quot;, data:&#123; person:&#123; name:&quot;linqingyu&quot;, sex:&quot;男&quot;, age:18 &#125; &#125; &#125;)&lt;/script&gt; 2、v-html123456789&lt;div id=&quot;demo&quot; v-html=&quot;msg&quot;&gt;&lt;/div&gt;//处理元素内部的html,可以带标签 不是纯文本&lt;script&gt; var app = new Vue(&#123; el:&quot;#demo&quot;, data:&#123; msg:&apos;&lt;img src=&quot;&quot;&gt;&apos; &#125; &#125;)&lt;/script&gt; 3、v-bind作用：v-bind绑定页面中的元素属性。例如：a的href属性，img的src、alt和title属性。语法：v-bind:元素的属性名 = “data中键名”1234567891011121314&lt;div id=&quot;demo&gt; &lt;a v-bind=&quot;hrefvalue&quot;&gt;//用v-bind绑定标签属性:后面是参数(标签属性名) &lt;img v-bind:src=&quot;source&quot; alt=&quot;&quot;&gt; &lt;/a&gt;&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:&quot;#demo&quot;, data:&#123; hrefvalue:&quot;http://www.baidu.com&quot;, source:&quot;img/i.jpg&quot; &#125; &#125;)&lt;/script&gt; 123456789101112131415&lt;div id=&quot;demo&quot; v-bind:style=&quot;styles&quot;&gt;//控制css 你好&lt;/div&gt;&lt;script&gt; var app = new Vue(&#123; el:&quot;#demo&quot;, data:&#123; styles:&#123; //控制css的style需要是一个对象,里面是css属性名(如果属性名中有 - ,那么需要写成驼峰试命名法) color:&quot;red&quot;, fontSize:&quot;30px&quot;, fontWeight:&quot;normal&quot; &#125; &#125; &#125;)&lt;/script&gt; 在view模板中，可以使用简单的JS表单式，例如：12&lt;p&gt;&#123;&#123;num==1?&apos;我爱北京&apos;:&apos;我爱承德&apos;&#125;&#125;&lt;/p&gt;//在view模板中可以是简单js表达式 4、 v-show作用：通过判断，是否显示该内容。如果值为true，则显示。否则就隐藏。语法：v-show=”判断表达式”特点：元素会始终渲染在DOM中，只是被设置了display:none12345678910111213&lt;p id=&quot;demo&quot; v-show=&quot;seen&quot;&gt; //如果seen为true，而现实下方的内容，否则就隐藏 如意娘&lt;br&gt; 武则天&lt;br&gt; ...&lt;/p&gt;&lt;script&gt;var app = new Vue(&#123; el:&apos;#demo&apos;, data:&#123; seen:true &lt;!--如果seen为true，那么就显示 文字，否则就隐藏--&gt; &#125;&#125;)；&lt;!--隐藏的时候只是设置了display：none属性，该元素是依然存在的--&gt; 5、v-if作用：判断是否加载固定的内容。如果为真，则加载；为假时，则不加载。用处：用在权限管理，页面条件加载语法：v-if=”判断表达式”特点：控制元素插进来或者删除，而不是隐藏。template 标签是不会被渲染的例 :123&lt;template&gt; &lt;div v-if=&quot;true&quot;&gt;hello&lt;/div&gt;&lt;/template&gt; 在页面里只显示div不显示template标签v-show不支持template语法v-if与v-show的区别：一般来说，v-if有更高的切换消耗，安全性更高，而v-show有更多的初始化渲染消耗。因此，如果需要频繁切换而对安全性无要求，使用v-show。如果在运行时，条件不可能改变，则使用v-if较好。6、v-elsev-else必须紧跟在v-if后面也可以跟在v-show后面，否则他不能被识别。表示：当v-if的条件不成立的时候执行。7、v-for作用：控制html元素中的循环，实现诗句列表的生成。用法：view : v-for=”item in 集合”item: 集合的子项集合：被遍历的集合，通常为数组。用处：写在谁上，谁循环。123&lt;li v-for=&quot;singer in singers&quot;&gt; &#123;&#123;singer.no&#125;&#125; &#123;&#123;singer.name&#125;&#125;&lt;/li&gt; 数据12345678data：&#123; singers：[ &#123;no:1,name:&apos;王菲&apos;&#125;， &#123;no:2,name:&apos;谢霆锋&apos;&#125;， &#123;no：3，name：&apos;张柏芝&apos;&#125;， &#123;no：4，name：&apos;钟欣潼&apos;&#125; ]&#125; 123&lt;li v-for=&quot;(singer,index) in singers&quot;&gt; &lt;!--singer为集合的子项，index为集合的索引值--&gt; &#123;&#123;singer.no&#125;&#125; &#123;&#123;singer.name&#125;&#125; (索引值为：&#123;&#123;index&#125;&#125;)&lt;/li&gt; 8、v-on作用：对页面中的事件进行绑定语法： v-on:事件类型=“事件处理函数名”缩写： @事件类型=“事件处理函数名”123456789101112131415161718192021&lt;ul id=&quot;demo&quot;&gt; &lt;li v-on:click=&quot;clickme&quot;&gt;单击事件&lt;/li&gt; &lt;li&gt;双击事件&lt;/li&gt; &lt;li&gt;鼠标移入事件&lt;/li&gt;&lt;/ul&gt;&lt;!--click为时间类型--clickme为时间处理函数的名字--&gt;&lt;script&gt;var app = new Vue(&#123;\ el:&apos;#demo&apos;, data:&#123; &#125;, methods:&#123; clickme:function()&#123; consloe.log(&apos;单机事件&apos;) &#125; &#125; &lt;!--clickme为事件处理函数的名字也为methods中方法的名字--&gt;&#125;)&lt;/script&gt; 用法：在view中，用v-on:事件类型=”methods中的方法名字”在vue实例中，在methods中去监听：也就书写methods的该方法。123456&lt;li v-on:click=&quot;clickme&quot;&gt;单击事件&lt;/li&gt;&lt;li @dblclick=&quot;clickme&quot;&gt;双击事件&lt;/li&gt;&lt;!--@是v-on：的缩写--&gt;&lt;li v-on:mouseenter=&quot;enterme()&quot;&gt;鼠标移入事件&lt;/li&gt;&lt;li @mouseleave=&quot;leaveme(&apos;parameter&apos;)&quot;&gt;鼠标离开事件&lt;/li&gt;&lt;!--enterme()方法后面的()可加可不加。但是需要传参，就必须加--&gt; 9、v-model作用：接受用户输入的一些数据，直接就可以将这些数据挂在到data属性上。这样就产生了双向的数据绑定（当业务模型中的数据发生变化时，用户界面中的数据会发生变化；当用户界面中的数据变化时，业务模型中的数据也会发生变化）。语法：v-model = “data中的键名”在data中，最好也要定义这个属性，不然会报错。数据双向绑定时候， 首次绑定数据，不随数据变化(只绑定一次)；初始化时候绑定，再次更改时候不改变；10、销毁]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
</search>
